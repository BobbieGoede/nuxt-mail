import { addImports, addPlugin, addServerHandler, addTypeTemplate, createResolver, defineNuxtModule } from "@nuxt/kit";
import { dirname, resolve } from "pathe";
import { fileURLToPath } from "node:url";

export const distDir = dirname(fileURLToPath(import.meta.url));
export const runtimeDir = fileURLToPath(new URL("./runtime", import.meta.url));

type MailMessage = {
  name?: string;
  to?: string;
  cc?: string;
  bcc?: string;
};

export interface ModuleOptions {
  message: MailMessage | MailMessage[];
  smtp: SMTPConnection.Options;
}

export interface GeneratedTypeConfig {}

export interface ModuleResolvedOptions {
  message: MailMessage[];
  smtp: SMTPConnection.Options;
}

declare module "@nuxt/schema" {
  interface NuxtConfig {
    ["mail"]?: Partial<ModuleOptions>;
  }
  interface NuxtOptions {
    ["mail"]?: ModuleOptions;
  }
}

import { MODULE_NAME } from "./constants";
import type SMTPConnection from "nodemailer/lib/smtp-connection";

export default defineNuxtModule<ModuleOptions>({
  meta: {
    name: MODULE_NAME,
    configKey: "mail",
  },
  async setup(moduleOptions, nuxt) {
    const options = { ...moduleOptions };
    const resolver = createResolver(import.meta.url);

    if (!options.smtp) {
      throw new Error("SMTP config is missing.");
    }

    options.message ??= [];

    // normalize `message` options to array
    if (!Array.isArray(options.message)) {
      options.message = [options.message];
    }

    // empty message option
    if (options.message.length == 0) {
      throw new Error("You have to provide at least one config.");
    }

    // invalid message option
    if (options.message.some((c: Partial<MailMessage>) => !c.to && !c.cc && !c.bcc)) {
      throw new Error("You have to provide to/cc/bcc in all configs.");
    }

    const serializedOptions = JSON.stringify(options, undefined, 2);
    nuxt.hook("nitro:config", async (nitroConfig) => {
      // add virtual options.mjs file to nitro
      nitroConfig.virtual ??= {};
      nitroConfig.virtual[`#internal/${MODULE_NAME}/options.mjs`] = `export default ${serializedOptions}`;

      // replace/define module name
      nitroConfig.replace ??= {};
      nitroConfig.replace["__MODULE_NAME__"] = MODULE_NAME;
    });

    const configNames = options.message.filter((x) => "name" in x && x.name).map((x) => x.name);
    if (configNames.length) {
      addTypeTemplate({
        filename: "nuxt-mail-types.d.ts",
        getContents() {
          return `// generated by ${MODULE_NAME}
declare module "${MODULE_NAME}" {
  interface GeneratedTypeConfig {
    configNames: ${configNames.map((x, i) => [i, JSON.stringify(x)].join(" | ")).join(" | ")};
  }
}
        `;
        },
      });
    }

    nuxt.options.alias["#mail"] = resolve(distDir, MODULE_NAME);

    addServerHandler({
      handler: resolver.resolve("runtime/server/server-handler.post"),
      route: "/mail/send",
    });

    addImports([{ from: resolver.resolve("runtime/composables"), name: "useMail" }]);

    addPlugin(resolve(runtimeDir, `plugin`));
  },
});
