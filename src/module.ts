import {
  addImports,
  addPlugin,
  addServerHandler,
  addTypeTemplate,
  createResolver,
  defineNuxtModule,
  useLogger,
} from "@nuxt/kit";
import type { MailMessage, ModuleOptions } from "./types";

export type { MailMessage, ModuleOptions, ModuleResolvedOptions, GeneratedTypeConfig } from "./types";

const MODULE_NAME = "@goede/nuxt-mail";

export default defineNuxtModule<ModuleOptions>({
  meta: {
    name: MODULE_NAME,
    configKey: "mail",
    compatibility: {
      nuxt: ">=3.0.0",
      bridge: false,
    },
  },
  setup(moduleOptions, nuxt) {
    const logger = useLogger(MODULE_NAME);
    const options = { ...moduleOptions } as ModuleOptions;
    const { resolve } = createResolver(import.meta.url);

    if (!options.smtp) {
      return logger.error("SMTP config is missing, disabling module.");
    }

    options.message ??= [];

    // normalize `message` options to array
    if (!Array.isArray(options.message)) {
      options.message = [options.message];
    }

    // empty message option
    if (options.message.length == 0) {
      return logger.error("No message configuration set, disabling module.");
    }

    if (options.message.some((c: Partial<MailMessage>) => !c.to && !c.cc && !c.bcc)) {
      return logger.error("Not all message configs have `to`, `cc` or `bcc` set, disabling module.");
    }

    // add composable auto-imports
    addImports([{ from: resolve("./runtime/composables"), name: "useMail" }]);

    // register plugin
    addPlugin(resolve(`./runtime/plugin`));

    // register server handler
    addServerHandler({ route: "/mail/send", handler: resolve("./runtime/server/server-handler.post") });

    const serializedOptions = JSON.stringify(options, undefined, 2);
    // add virtual options.mjs file to nitro
    nuxt.hook("nitro:config", (config) => {
      config.virtual![`#internal/@goede/nuxt-mail/options.mjs`] = `export const options = ${serializedOptions}`;
    });

    addTypeTemplate({
      filename: "types/nuxt-mail-types.d.ts",
      getContents: () => {
        const configNames = (options.message as MailMessage[]).filter((x) => "name" in x && x.name).map((x) => x.name);
        const configNamesType = configNames.map((x, i) => [i, JSON.stringify(x)].join(" | ")).join(" | ");

        return `// generated by ${MODULE_NAME}
declare module "${MODULE_NAME}" {
  interface GeneratedTypeConfig {
    configNames: ${configNamesType || "never"};
  }
}`;
      },
    });
  },
});
